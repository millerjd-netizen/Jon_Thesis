#!/usr/bin/env python3
"""
DIGESTER DATA LOGGER
====================
Captures Serial data from Arduino and saves to timestamped CSV files.
Creates a new CSV file every hour.

USAGE:
    python digester_logger.py

REQUIREMENTS:
    pip install pyserial

The script will auto-detect the Arduino port, or you can specify it manually.
"""

import serial
import serial.tools.list_ports
import os
import sys
from datetime import datetime
import time

# ================================================================
# CONFIGURATION
# ================================================================
BAUD_RATE = 115200
OUTPUT_DIR = "digester_logs"  # Folder to save CSV files
FILE_ROTATION_MINUTES = 60    # Create new file every 60 minutes (1 hour)

# ================================================================
# AUTO-DETECT ARDUINO PORT
# ================================================================
def find_arduino_port():
    """Find Arduino port automatically"""
    ports = serial.tools.list_ports.comports()
    
    for port in ports:
        # Look for common Arduino identifiers
        if any(x in port.description.lower() for x in ['arduino', 'giga', 'usb serial', 'ch340', 'cp210']):
            return port.device
        if any(x in port.manufacturer.lower() if port.manufacturer else '' for x in ['arduino', 'wch']):
            return port.device
    
    # If no Arduino found, list available ports
    print("Available ports:")
    for port in ports:
        print(f"  {port.device}: {port.description}")
    
    return None

# ================================================================
# CSV FILE MANAGEMENT
# ================================================================
class CSVLogger:
    def __init__(self, output_dir, rotation_minutes):
        self.output_dir = output_dir
        self.rotation_minutes = rotation_minutes
        self.current_file = None
        self.current_file_path = None
        self.file_start_time = None
        self.header = None
        
        # Create output directory
        os.makedirs(output_dir, exist_ok=True)
        print(f"CSV files will be saved to: {os.path.abspath(output_dir)}")
    
    def _create_new_file(self):
        """Create a new timestamped CSV file"""
        if self.current_file:
            self.current_file.close()
            print(f">>> Closed: {self.current_file_path}")
        
        # Create filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"digester_data_{timestamp}.csv"
        self.current_file_path = os.path.join(self.output_dir, filename)
        
        self.current_file = open(self.current_file_path, 'w', newline='')
        self.file_start_time = datetime.now()
        
        # Write header if we have one
        if self.header:
            self.current_file.write(self.header + '\n')
            self.current_file.flush()
        
        print(f"")
        print(f"========================================")
        print(f">>> NEW CSV FILE: {filename}")
        print(f">>> Time: {self.file_start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"========================================")
        print(f"")
    
    def _check_rotation(self):
        """Check if it's time to rotate to a new file"""
        if self.file_start_time is None:
            self._create_new_file()
            return
        
        elapsed = (datetime.now() - self.file_start_time).total_seconds() / 60
        if elapsed >= self.rotation_minutes:
            self._create_new_file()
    
    def set_header(self, header):
        """Set the CSV header"""
        self.header = header
        if self.current_file:
            # If file exists but no header written yet, write it
            pass  # Header already written when file created
    
    def write_data(self, data_line):
        """Write a data line to the current CSV file"""
        self._check_rotation()
        
        if self.current_file:
            self.current_file.write(data_line + '\n')
            self.current_file.flush()  # Ensure data is written immediately
    
    def close(self):
        """Close the current file"""
        if self.current_file:
            self.current_file.close()
            print(f">>> Final file closed: {self.current_file_path}")

# ================================================================
# MAIN LOGGER
# ================================================================
def main():
    print("")
    print("=" * 60)
    print("  ANAEROBIC DIGESTER DATA LOGGER")
    print("  Captures Arduino data and saves hourly CSV files")
    print("=" * 60)
    print("")
    
    # Find Arduino port
    port = find_arduino_port()
    
    if port is None:
        print("\nNo Arduino detected!")
        print("Please specify the port manually:")
        print("  Windows: COM3, COM4, etc.")
        print("  Mac/Linux: /dev/ttyUSB0, /dev/ttyACM0, etc.")
        port = input("\nEnter port: ").strip()
    
    print(f"\nConnecting to Arduino on {port}...")
    
    try:
        ser = serial.Serial(port, BAUD_RATE, timeout=1)
        time.sleep(2)  # Wait for Arduino to reset
        print("Connected!")
        print("")
    except serial.SerialException as e:
        print(f"Error: Could not open port {port}")
        print(f"  {e}")
        sys.exit(1)
    
    # Create CSV logger
    logger = CSVLogger(OUTPUT_DIR, FILE_ROTATION_MINUTES)
    
    print("Listening for data... (Press Ctrl+C to stop)")
    print("-" * 60)
    
    try:
        while True:
            if ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='ignore').strip()
                
                if not line:
                    continue
                
                # Check for CSV header
                if line.startswith("CSVHEADER,"):
                    header = line[10:]  # Remove "CSVHEADER," prefix
                    logger.set_header(header)
                    print(f"[HEADER] {header}")
                
                # Check for data line
                elif line.startswith("DATA,"):
                    data = line[5:]  # Remove "DATA," prefix
                    logger.write_data(data)
                    # Also print to console (shortened)
                    parts = data.split(',')
                    if len(parts) >= 6:
                        print(f"[LOG] T{parts[1]} {parts[2]:12s} pH={parts[8]:>6s} ORP={parts[10]:>8s} HRT={parts[13]}")
                
                # Print all other lines (human-readable output)
                else:
                    print(line)
    
    except KeyboardInterrupt:
        print("\n")
        print("=" * 60)
        print("  LOGGER STOPPED BY USER")
        print("=" * 60)
    
    finally:
        logger.close()
        ser.close()
        print(f"\nAll data saved to: {os.path.abspath(OUTPUT_DIR)}")

if __name__ == "__main__":
    main()
