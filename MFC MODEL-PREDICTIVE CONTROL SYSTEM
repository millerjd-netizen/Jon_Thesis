// ============================================
// MFC MODEL-PREDICTIVE CONTROL SYSTEM
// Arduino Giga
// 
// Physics-based dose calculation using CSTR mixing equation:
// V_dose = V * (target - current) / (substrate - target)
//
// - Calculates exact dose volume needed to reach setpoint
// - Doses ONE substrate at a time
// - Evaluates every 1 minute
// - Priority: pH > TAN > EC
// ============================================

// === PIN DEFINITIONS ===
#define PUMP_WINE      0   // D0 - Wine pump relay
#define PUMP_URINE     1   // D1 - Urine pump relay
#define PUMP_SPIRULINA 2   // D2 - Spirulina pump relay
#define STATUS_LED     3   // D3 - Status LED
#define PH_SENSOR      A0  // Analog pH input
#define EC_SENSOR      A1  // Analog EC input
#define NH4_SENSOR     A2  // Analog ammonia input

// === TARGET SETPOINTS ===
const float PH_SETPOINT   = 7.0;
const float PH_MIN        = 6.8;
const float PH_MAX        = 7.2;
const float EC_SETPOINT   = 7.5;   // mS/cm
const float EC_MIN        = 5.0;
const float EC_MAX        = 10.0;
const float TAN_SETPOINT  = 125.0; // mg-N/L
const float TAN_MIN       = 50.0;
const float TAN_MAX       = 200.0;

// === TRACE METAL TARGETS (mg/L) - tracked, not controlled ===
const float FE_MIN = 1.0,  FE_MAX = 10.0;
const float ZN_MIN = 0.1,  ZN_MAX = 1.0;
const float CU_MIN = 0.01, CU_MAX = 0.5;
const float MN_MIN = 0.1,  MN_MAX = 1.0;
const float SE_MIN = 0.01, SE_MAX = 0.1;
const float NI_MIN = 0.05, NI_MAX = 1.0;
const float CO_MIN = 0.01, CO_MAX = 0.3;

// === DOSING CONSTRAINTS ===
const float MIN_DOSE_ML = 0.5;    // Minimum practical dose
const float MAX_DOSE_ML = 50.0;   // Maximum single dose
const float PUMP_ML_PER_SEC = 1.67; // Pump flow rate (calibrate this!)

// === CONTROL TIMING ===
const unsigned long CONTROL_INTERVAL = 60000; // 1 minute in ms

// === REACTOR PARAMETERS ===
float reactorVolume = 1000.0;  // mL (will increase with dosing)

// === SENSOR CALIBRATION ===
const float PH_SLOPE      = -0.0178;
const float PH_OFFSET     = 21.34;
const float EC_SLOPE      = 0.0244;
const float EC_OFFSET     = 0.0;
const float TAN_SLOPE     = 0.488;
const float TAN_OFFSET    = 0.0;

// === AUTONOMOUS DYNAMICS (for drift simulation/prediction) ===
const float A_PH  = -0.0001;   // per minute
const float A_EC  = -0.0001;   // per minute
const float A_TAN = -0.00003;  // per minute
const float D_PH  = -0.0005;   // pH/min
const float D_EC  = -0.001;    // mS/cm/min
const float D_TAN = -0.3;      // mg-N/L/min
const float METAL_DECAY_RATE = 0.0005; // per minute

// === SUBSTRATE PROPERTIES ===
// Wine (100:1 diluted)
const float WINE_PH  = 4.0;
const float WINE_EC  = 0.02;
const float WINE_TAN = 0.1;
const float WINE_FE  = 0.05;
const float WINE_ZN  = 0.01;
const float WINE_CU  = 0.001;
const float WINE_MN  = 0.02;
const float WINE_SE  = 0.0;
const float WINE_NI  = 0.0;
const float WINE_CO  = 0.0;

// Urine (4:1 diluted fermented)
const float URINE_PH  = 8.5;
const float URINE_EC  = 6.25;
const float URINE_TAN = 200.0;
const float URINE_FE  = 0.01;
const float URINE_ZN  = 0.05;
const float URINE_CU  = 0.01;
const float URINE_MN  = 0.005;
const float URINE_SE  = 0.001;
const float URINE_NI  = 0.002;
const float URINE_CO  = 0.001;

// Spirulina (15 g/L)
const float SPIR_PH  = 9.0;
const float SPIR_EC  = 1.14;
const float SPIR_TAN = 144.0;
const float SPIR_FE  = 4.275;
const float SPIR_ZN  = 0.300;
const float SPIR_CU  = 0.915;
const float SPIR_MN  = 0.285;
const float SPIR_SE  = 0.00105;
const float SPIR_NI  = 0.0;
const float SPIR_CO  = 0.0;

// === STATE VARIABLES ===
unsigned long lastControlTime = 0;
float currentPH  = 7.0;
float currentEC  = 5.5;
float currentTAN = 80.0;

// Trace metals (mg/L) - estimated, not measured
float currentFe = 1.0;
float currentZn = 0.1;
float currentCu = 0.05;
float currentMn = 0.1;
float currentSe = 0.01;
float currentNi = 0.01;
float currentCo = 0.01;

// Dose tracking
float totalWineML = 0;
float totalUrineML = 0;
float totalSpirML = 0;
int doseCountWine = 0;
int doseCountUrine = 0;
int doseCountSpir = 0;

// ============================================
// CSTR PHYSICS: Calculate exact dose volume
// ============================================
// 
// CSTR mixing equation:
//   x_new = (x_current * V + x_substrate * V_dose) / (V + V_dose)
//
// Solving for V_dose to reach target:
//   V_dose = V * (target - current) / (substrate - target)
//
float calculateDoseVolume(float current, float target, float substrateVal, float volume) {
  // Check if substrate can move us toward target
  if (abs(substrateVal - current) < 0.0001) {
    return 0;  // Substrate same as current, can't help
  }
  
  // Check direction - does substrate move us toward or away from target?
  bool needIncrease = (target > current);
  bool substrateHigher = (substrateVal > current);
  
  if (needIncrease != substrateHigher) {
    return 0;  // Wrong substrate - would move away from target
  }
  
  // Calculate required dose
  float denom = substrateVal - target;
  if (abs(denom) < 0.0001) {
    return MAX_DOSE_ML;  // Substrate equals target, would need infinite dose
  }
  
  float dose = volume * (target - current) / denom;
  
  // Clamp to valid range
  if (dose < MIN_DOSE_ML) {
    return 0;  // Too small to be practical
  }
  return min(dose, MAX_DOSE_ML);
}

// ============================================
// MPC CONTROL DECISION
// ============================================
// Returns: 0=none, 1=wine, 2=urine, 3=spirulina
// Sets doseML to the calculated volume

int mpcControlDecision(float* doseML, char* reason) {
  *doseML = 0;
  
  // === PRIORITY 1: pH control ===
  if (currentPH > PH_MAX) {
    // pH too high - need wine (acidic) to lower it
    float dose = calculateDoseVolume(currentPH, PH_SETPOINT, WINE_PH, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "pH HIGH (%.2f>%.1f) -> wine to %.1f", currentPH, PH_MAX, PH_SETPOINT);
      return 1;
    }
  }
  
  if (currentPH < PH_MIN) {
    // pH too low - need urine (basic) to raise it
    float dose = calculateDoseVolume(currentPH, PH_SETPOINT, URINE_PH, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "pH LOW (%.2f<%.1f) -> urine to %.1f", currentPH, PH_MIN, PH_SETPOINT);
      return 2;
    }
  }
  
  // === PRIORITY 2 & 3: TAN and EC combined logic ===
  if (currentTAN < TAN_MIN && currentEC < EC_MIN) {
    // Both low - urine provides both TAN and EC
    float dose = calculateDoseVolume(currentTAN, TAN_SETPOINT, URINE_TAN, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "TAN+EC LOW (TAN=%.1f, EC=%.2f) -> urine", currentTAN, currentEC);
      return 2;
    }
  }
  
  if (currentTAN < TAN_MIN) {
    // TAN low, EC is OK - use spirulina
    float dose = calculateDoseVolume(currentTAN, TAN_SETPOINT, SPIR_TAN, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "TAN LOW (%.1f<%.1f) -> spirulina", currentTAN, TAN_MIN);
      return 3;
    }
  }
  
  if (currentEC < EC_MIN) {
    // EC low, TAN is OK - use urine for EC
    float dose = calculateDoseVolume(currentEC, EC_SETPOINT, URINE_EC, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "EC LOW (%.2f<%.1f) -> urine", currentEC, EC_MIN);
      return 2;
    }
  }
  
  // All in range
  strcpy(reason, "All parameters in range");
  return 0;
}

// ============================================
// DOSING EXECUTION WITH CSTR MIXING
// ============================================

void executeDose(int substrate, float doseML) {
  if (doseML < MIN_DOSE_ML) return;
  
  int pumpPin;
  float subPH, subEC, subTAN;
  float subFe, subZn, subCu, subMn, subSe, subNi, subCo;
  const char* name;
  
  switch (substrate) {
    case 1: // Wine
      pumpPin = PUMP_WINE;
      subPH = WINE_PH; subEC = WINE_EC; subTAN = WINE_TAN;
      subFe = WINE_FE; subZn = WINE_ZN; subCu = WINE_CU;
      subMn = WINE_MN; subSe = WINE_SE; subNi = WINE_NI; subCo = WINE_CO;
      name = "WINE";
      totalWineML += doseML;
      doseCountWine++;
      break;
      
    case 2: // Urine
      pumpPin = PUMP_URINE;
      subPH = URINE_PH; subEC = URINE_EC; subTAN = URINE_TAN;
      subFe = URINE_FE; subZn = URINE_ZN; subCu = URINE_CU;
      subMn = URINE_MN; subSe = URINE_SE; subNi = URINE_NI; subCo = URINE_CO;
      name = "URINE";
      totalUrineML += doseML;
      doseCountUrine++;
      break;
      
    case 3: // Spirulina
      pumpPin = PUMP_SPIRULINA;
      subPH = SPIR_PH; subEC = SPIR_EC; subTAN = SPIR_TAN;
      subFe = SPIR_FE; subZn = SPIR_ZN; subCu = SPIR_CU;
      subMn = SPIR_MN; subSe = SPIR_SE; subNi = SPIR_NI; subCo = SPIR_CO;
      name = "SPIRULINA";
      totalSpirML += doseML;
      doseCountSpir++;
      break;
      
    default:
      return;
  }
  
  // Calculate pump time
  float pumpTimeSec = doseML / PUMP_ML_PER_SEC;
  unsigned long pumpTimeMS = (unsigned long)(pumpTimeSec * 1000);
  
  // Print dose info
  Serial.print(F(">> DOSING ")); Serial.print(name);
  Serial.print(F(": ")); Serial.print(doseML, 1); Serial.print(F(" mL ("));
  Serial.print(pumpTimeSec, 1); Serial.println(F(" sec)"));
  
  // Calculate expected post-dose state (CSTR mixing)
  float newVol = reactorVolume + doseML;
  float newPH  = (currentPH * reactorVolume + subPH * doseML) / newVol;
  float newEC  = (currentEC * reactorVolume + subEC * doseML) / newVol;
  float newTAN = (currentTAN * reactorVolume + subTAN * doseML) / newVol;
  
  Serial.print(F("   Expected: pH=")); Serial.print(newPH, 2);
  Serial.print(F(" EC=")); Serial.print(newEC, 2);
  Serial.print(F(" TAN=")); Serial.println(newTAN, 1);
  
  // Activate pump
  digitalWrite(pumpPin, HIGH);
  delay(pumpTimeMS);
  digitalWrite(pumpPin, LOW);
  
  // Update state using CSTR mixing physics
  currentPH  = (currentPH * reactorVolume + subPH * doseML) / newVol;
  currentEC  = (currentEC * reactorVolume + subEC * doseML) / newVol;
  currentTAN = (currentTAN * reactorVolume + subTAN * doseML) / newVol;
  
  // Update trace metals
  currentFe = (currentFe * reactorVolume + subFe * doseML) / newVol;
  currentZn = (currentZn * reactorVolume + subZn * doseML) / newVol;
  currentCu = (currentCu * reactorVolume + subCu * doseML) / newVol;
  currentMn = (currentMn * reactorVolume + subMn * doseML) / newVol;
  currentSe = (currentSe * reactorVolume + subSe * doseML) / newVol;
  currentNi = (currentNi * reactorVolume + subNi * doseML) / newVol;
  currentCo = (currentCo * reactorVolume + subCo * doseML) / newVol;
  
  reactorVolume = newVol;
}

// ============================================
// SENSOR READING
// ============================================

void readSensors() {
  long phRaw = 0, ecRaw = 0, tanRaw = 0;
  
  // Average 10 readings for noise reduction
  for (int i = 0; i < 10; i++) {
    phRaw  += analogRead(PH_SENSOR);
    ecRaw  += analogRead(EC_SENSOR);
    tanRaw += analogRead(NH4_SENSOR);
    delay(10);
  }
  phRaw  /= 10;
  ecRaw  /= 10;
  tanRaw /= 10;
  
  // Convert to units
  currentPH  = PH_SLOPE * phRaw + PH_OFFSET;
  currentEC  = EC_SLOPE * ecRaw + EC_OFFSET;
  currentTAN = TAN_SLOPE * tanRaw + TAN_OFFSET;
  
  // Constrain to valid ranges
  currentPH  = constrain(currentPH, 0.0, 14.0);
  currentEC  = constrain(currentEC, 0.0, 50.0);
  currentTAN = constrain(currentTAN, 0.0, 1000.0);
}

// ============================================
// DRIFT APPLICATION (for simulation/prediction)
// ============================================

void applyDrift(float dt) {
  // State-dependent decay (Ax) + constant drift (d)
  float dPH  = A_PH * currentPH + D_PH;
  float dEC  = A_EC * currentEC + D_EC;
  float dTAN = A_TAN * currentTAN + D_TAN;
  
  // Euler integration
  currentPH  += dPH * dt;
  currentEC  += dEC * dt;
  currentTAN += dTAN * dt;
  
  // Metal decay (first-order)
  float decayFactor = exp(-METAL_DECAY_RATE * dt);
  currentFe *= decayFactor;
  currentZn *= decayFactor;
  currentCu *= decayFactor;
  currentMn *= decayFactor;
  currentSe *= decayFactor;
  currentNi *= decayFactor;
  currentCo *= decayFactor;
  
  // Enforce non-negative
  currentPH  = max(0.0, currentPH);
  currentEC  = max(0.01, currentEC);
  currentTAN = max(0.0, currentTAN);
}

// ============================================
// STATUS DISPLAY
// ============================================

void printStatus() {
  Serial.println(F("\n=== MFC STATUS ==="));
  
  // pH
  Serial.print(F("pH:  "));
  Serial.print(currentPH, 2);
  if (currentPH < PH_MIN) Serial.print(F(" [LOW]"));
  else if (currentPH > PH_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.print(F("  (target: ")); Serial.print(PH_MIN); 
  Serial.print(F("-")); Serial.print(PH_MAX); 
  Serial.print(F(", setpoint: ")); Serial.print(PH_SETPOINT); Serial.println(F(")"));
  
  // EC
  Serial.print(F("EC:  "));
  Serial.print(currentEC, 2);
  Serial.print(F(" mS/cm"));
  if (currentEC < EC_MIN) Serial.print(F(" [LOW]"));
  else if (currentEC > EC_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.print(F("  (target: ")); Serial.print(EC_MIN); 
  Serial.print(F("-")); Serial.print(EC_MAX); Serial.println(F(")"));
  
  // TAN
  Serial.print(F("TAN: "));
  Serial.print(currentTAN, 1);
  Serial.print(F(" mg-N/L"));
  if (currentTAN < TAN_MIN) Serial.print(F(" [LOW]"));
  else if (currentTAN > TAN_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.print(F("  (target: ")); Serial.print(TAN_MIN); 
  Serial.print(F("-")); Serial.print(TAN_MAX); Serial.println(F(")"));
  
  // Volume
  Serial.print(F("Vol: "));
  Serial.print(reactorVolume, 0);
  Serial.println(F(" mL"));
  
  // Dose totals
  Serial.print(F("Dosed: Wine=")); Serial.print(totalWineML, 0);
  Serial.print(F("mL(")); Serial.print(doseCountWine); Serial.print(F(")"));
  Serial.print(F(" Urine=")); Serial.print(totalUrineML, 0);
  Serial.print(F("mL(")); Serial.print(doseCountUrine); Serial.print(F(")"));
  Serial.print(F(" Spir=")); Serial.print(totalSpirML, 0);
  Serial.print(F("mL(")); Serial.print(doseCountSpir); Serial.println(F(")"));
}

void printMetals() {
  Serial.println(F("--- TRACE METALS (mg/L) ---"));
  
  Serial.print(F("  Fe: ")); Serial.print(currentFe, 4);
  if (currentFe < FE_MIN) Serial.print(F(" [LOW]"));
  else if (currentFe > FE_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Zn: ")); Serial.print(currentZn, 4);
  if (currentZn < ZN_MIN) Serial.print(F(" [LOW]"));
  else if (currentZn > ZN_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Cu: ")); Serial.print(currentCu, 4);
  if (currentCu < CU_MIN) Serial.print(F(" [LOW]"));
  else if (currentCu > CU_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Mn: ")); Serial.print(currentMn, 4);
  if (currentMn < MN_MIN) Serial.print(F(" [LOW]"));
  else if (currentMn > MN_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Se: ")); Serial.print(currentSe, 5);
  if (currentSe < SE_MIN) Serial.print(F(" [LOW]"));
  else if (currentSe > SE_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Ni: ")); Serial.print(currentNi, 5);
  if (currentNi < NI_MIN) Serial.print(F(" [LOW]"));
  else if (currentNi > NI_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Co: ")); Serial.print(currentCo, 5);
  if (currentCo < CO_MIN) Serial.print(F(" [LOW]"));
  else if (currentCo > CO_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
}

// ============================================
// SETUP
// ============================================

void setup() {
  Serial.begin(115200);
  
  pinMode(PUMP_WINE, OUTPUT);
  pinMode(PUMP_URINE, OUTPUT);
  pinMode(PUMP_SPIRULINA, OUTPUT);
  pinMode(STATUS_LED, OUTPUT);
  
  digitalWrite(PUMP_WINE, LOW);
  digitalWrite(PUMP_URINE, LOW);
  digitalWrite(PUMP_SPIRULINA, LOW);
  
  Serial.println(F("============================================"));
  Serial.println(F("MFC MODEL-PREDICTIVE CONTROL"));
  Serial.println(F("Physics-based dose calculation"));
  Serial.println(F("============================================"));
  Serial.println(F(""));
  Serial.println(F("CSTR mixing equation:"));
  Serial.println(F("  V_dose = V * (target - current) / (substrate - target)"));
  Serial.println(F(""));
  Serial.print(F("Dose range: ")); Serial.print(MIN_DOSE_ML, 1);
  Serial.print(F(" - ")); Serial.print(MAX_DOSE_ML, 1); Serial.println(F(" mL"));
  Serial.print(F("Control interval: ")); Serial.print(CONTROL_INTERVAL/1000);
  Serial.println(F(" seconds"));
  Serial.println(F(""));
  Serial.println(F("Targets:"));
  Serial.print(F("  pH:  ")); Serial.print(PH_MIN); Serial.print(F("-")); 
  Serial.print(PH_MAX); Serial.print(F(" (setpoint ")); 
  Serial.print(PH_SETPOINT); Serial.println(F(")"));
  Serial.print(F("  EC:  ")); Serial.print(EC_MIN); Serial.print(F("-")); 
  Serial.print(EC_MAX); Serial.print(F(" mS/cm (setpoint "));
  Serial.print(EC_SETPOINT); Serial.println(F(")"));
  Serial.print(F("  TAN: ")); Serial.print(TAN_MIN); Serial.print(F("-")); 
  Serial.print(TAN_MAX); Serial.print(F(" mg-N/L (setpoint "));
  Serial.print(TAN_SETPOINT); Serial.println(F(")"));
  Serial.println(F(""));
  Serial.println(F("Priority: pH > TAN > EC"));
  Serial.println(F("============================================"));
  Serial.println(F(""));
}

// ============================================
// MAIN LOOP
// ============================================

void loop() {
  unsigned long now = millis();
  
  if (now - lastControlTime >= CONTROL_INTERVAL) {
    lastControlTime = now;
    digitalWrite(STATUS_LED, HIGH);
    
    // Read sensors
    readSensors();
    
    // Display current state
    printStatus();
    
    // MPC control decision
    float doseML = 0;
    char reason[80];
    int action = mpcControlDecision(&doseML, reason);
    
    Serial.print(F("\n>> DECISION: ")); Serial.println(reason);
    
    // Execute dose if needed
    if (action > 0 && doseML >= MIN_DOSE_ML) {
      executeDose(action, doseML);
    }
    
    // Show trace metals periodically (every 10 cycles)
    static int cycleCount = 0;
    if (++cycleCount >= 10) {
      printMetals();
      cycleCount = 0;
    }
    
    digitalWrite(STATUS_LED, LOW);
    Serial.println();
  }
}
