// ============================================
// MFC MODEL-PREDICTIVE CONTROL SYSTEM
// Arduino Giga
// 
// Physics-based dose calculation using CSTR mixing equation:
// V_dose = V * (target - current) / (substrate - target)
//
// - Calculates exact dose volume needed to reach setpoint
// - Doses ONE substrate at a time
// - Evaluates every 1 minute
// - Priority: pH > DO > EC
// ============================================

// === PIN DEFINITIONS ===
#define PUMP_WINE      0   // D0 - Wine pump relay
#define PUMP_URINE     1   // D1 - Urine pump relay
#define PUMP_SPIRULINA 2   // D2 - Spirulina pump relay
#define STATUS_LED     3   // D3 - Status LED
#define PH_SENSOR      A0  // Analog pH input
#define EC_SENSOR      A1  // Analog EC input
#define DO_SENSOR      A2  // Analog dissolved oxygen input

// === TARGET SETPOINTS ===
const float PH_SETPOINT   = 7.0;
const float PH_MIN        = 6.8;
const float PH_MAX        = 7.2;
const float EC_SETPOINT   = 7.5;   // mS/cm
const float EC_MIN        = 5.0;
const float EC_MAX        = 10.0;
const float DO_SETPOINT   = 6.0;   // mg/L
const float DO_MIN        = 4.0;   // mg/L (below this is hypoxic)
const float DO_MAX        = 8.0;   // mg/L

// === DO SATURATION AND REAERATION ===
const float DO_SATURATION = 8.5;   // mg/L at ~20°C, 1 atm
const float KLA           = 0.1;   // reaeration coefficient (per minute)

// === TRACE METAL TARGETS (mg/L) - tracked, not controlled ===
const float FE_MIN = 1.0,  FE_MAX = 10.0;
const float ZN_MIN = 0.1,  ZN_MAX = 1.0;
const float CU_MIN = 0.01, CU_MAX = 0.5;
const float MN_MIN = 0.1,  MN_MAX = 1.0;
const float SE_MIN = 0.01, SE_MAX = 0.1;
const float NI_MIN = 0.05, NI_MAX = 1.0;
const float CO_MIN = 0.01, CO_MAX = 0.3;

// === DOSING CONSTRAINTS ===
const float MIN_DOSE_ML = 0.5;    // Minimum practical dose
const float MAX_DOSE_ML = 50.0;   // Maximum single dose
const float PUMP_ML_PER_SEC = 1.67; // Pump flow rate (calibrate this!)

// === CONTROL TIMING ===
const unsigned long CONTROL_INTERVAL = 60000; // 1 minute in ms

// === REACTOR PARAMETERS ===
float reactorVolume = 1000.0;  // mL (will increase with dosing)

// === SENSOR CALIBRATION ===
const float PH_SLOPE      = -0.0178;
const float PH_OFFSET     = 21.34;
const float EC_SLOPE      = 0.0244;
const float EC_OFFSET     = 0.0;
const float DO_SLOPE      = 0.0195;  // Calibrated for DO probe
const float DO_OFFSET     = 0.0;

// === AUTONOMOUS DYNAMICS ===
// State equation: dx/dt = Ax + d
// For DO: dDO/dt = A_DO*DO + D_DO + kLa*(DO_sat - DO)
//
// The DO equation models:
//   - A_DO*DO:  Biomass-dependent O2 consumption (more DO = faster uptake)
//   - D_DO:     Baseline O2 consumption (respiration, oxidation)
//   - kLa*(DO_sat - DO): Reaeration (O2 transfer from atmosphere)
//
// At steady state (no inputs):
//   DO_ss = (D_DO + kLa*DO_sat) / (kLa - A_DO)
//   With current params: DO_ss ≈ 6.67 mg/L

const float A_PH  = -0.0001;   // per minute
const float A_EC  = -0.0001;   // per minute
const float A_DO  = -0.005;    // per minute (DO-dependent consumption)

const float D_PH  = -0.0005;   // pH/min (CO2/VFA production)
const float D_EC  = -0.001;    // mS/cm/min (ion uptake)
const float D_DO  = -0.15;     // mg/L/min (baseline O2 consumption)

const float METAL_DECAY_RATE = 0.0005; // per minute

// === SUBSTRATE PROPERTIES ===
// Wine (100:1 diluted) - organic load consumes O2
const float WINE_PH  = 4.0;
const float WINE_EC  = 0.02;
const float WINE_DO  = 2.0;    // Low DO (organics strip oxygen)
const float WINE_FE  = 0.05;
const float WINE_ZN  = 0.01;
const float WINE_CU  = 0.001;
const float WINE_MN  = 0.02;
const float WINE_SE  = 0.0;
const float WINE_NI  = 0.0;
const float WINE_CO  = 0.0;

// Urine (4:1 diluted fermented) - moderate DO
const float URINE_PH  = 8.5;
const float URINE_EC  = 6.25;
const float URINE_DO  = 3.0;   // Low-moderate DO (ammonia oxidation demand)
const float URINE_FE  = 0.01;
const float URINE_ZN  = 0.05;
const float URINE_CU  = 0.01;
const float URINE_MN  = 0.005;
const float URINE_SE  = 0.001;
const float URINE_NI  = 0.002;
const float URINE_CO  = 0.001;

// Spirulina (15 g/L) - photosynthetic, high DO
const float SPIR_PH  = 9.0;
const float SPIR_EC  = 1.14;
const float SPIR_DO  = 12.0;   // Supersaturated from photosynthesis
const float SPIR_FE  = 4.275;
const float SPIR_ZN  = 0.300;
const float SPIR_CU  = 0.915;
const float SPIR_MN  = 0.285;
const float SPIR_SE  = 0.00105;
const float SPIR_NI  = 0.0;
const float SPIR_CO  = 0.0;

// === STATE VARIABLES ===
unsigned long lastControlTime = 0;
float currentPH  = 7.0;
float currentEC  = 5.5;
float currentDO  = 6.0;   // mg/L

// Trace metals (mg/L) - estimated, not measured
float currentFe = 1.0;
float currentZn = 0.1;
float currentCu = 0.05;
float currentMn = 0.1;
float currentSe = 0.01;
float currentNi = 0.01;
float currentCo = 0.01;

// Dose tracking
float totalWineML = 0;
float totalUrineML = 0;
float totalSpirML = 0;
int doseCountWine = 0;
int doseCountUrine = 0;
int doseCountSpir = 0;

// ============================================
// CSTR PHYSICS: Calculate exact dose volume
// ============================================
// 
// CSTR mixing equation:
//   x_new = (x_current * V + x_substrate * V_dose) / (V + V_dose)
//
// Solving for V_dose to reach target:
//   V_dose = V * (target - current) / (substrate - target)
//
float calculateDoseVolume(float current, float target, float substrateVal, float volume) {
  // Check if substrate can move us toward target
  if (abs(substrateVal - current) < 0.0001) {
    return 0;  // Substrate same as current, can't help
  }
  
  // Check direction - does substrate move us toward or away from target?
  bool needIncrease = (target > current);
  bool substrateHigher = (substrateVal > current);
  
  if (needIncrease != substrateHigher) {
    return 0;  // Wrong substrate - would move away from target
  }
  
  // Calculate required dose
  float denom = substrateVal - target;
  if (abs(denom) < 0.0001) {
    return MAX_DOSE_ML;  // Substrate equals target, would need infinite dose
  }
  
  float dose = volume * (target - current) / denom;
  
  // Clamp to valid range
  if (dose < MIN_DOSE_ML) {
    return 0;  // Too small to be practical
  }
  return min(dose, MAX_DOSE_ML);
}

// ============================================
// MPC CONTROL DECISION
// ============================================
// Returns: 0=none, 1=wine, 2=urine, 3=spirulina
// Sets doseML to the calculated volume

int mpcControlDecision(float* doseML, char* reason) {
  *doseML = 0;
  
  // === PRIORITY 1: pH control ===
  if (currentPH > PH_MAX) {
    // pH too high - need wine (acidic) to lower it
    float dose = calculateDoseVolume(currentPH, PH_SETPOINT, WINE_PH, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "pH HIGH (%.2f>%.1f) -> wine to %.1f", currentPH, PH_MAX, PH_SETPOINT);
      return 1;
    }
  }
  
  if (currentPH < PH_MIN) {
    // pH too low - need urine (basic) to raise it
    float dose = calculateDoseVolume(currentPH, PH_SETPOINT, URINE_PH, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "pH LOW (%.2f<%.1f) -> urine to %.1f", currentPH, PH_MIN, PH_SETPOINT);
      return 2;
    }
  }
  
  // === PRIORITY 2: DO control (critical for aerobic processes) ===
  if (currentDO < DO_MIN) {
    // DO too low - need spirulina (photosynthetic O2)
    float dose = calculateDoseVolume(currentDO, DO_SETPOINT, SPIR_DO, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "DO LOW (%.2f<%.1f) -> spirulina to %.1f", currentDO, DO_MIN, DO_SETPOINT);
      return 3;
    }
  }
  
  // === PRIORITY 3: EC control ===
  if (currentEC < EC_MIN) {
    // EC low - use urine for EC
    float dose = calculateDoseVolume(currentEC, EC_SETPOINT, URINE_EC, reactorVolume);
    if (dose >= MIN_DOSE_ML) {
      *doseML = dose;
      sprintf(reason, "EC LOW (%.2f<%.1f) -> urine to %.1f", currentEC, EC_MIN, EC_SETPOINT);
      return 2;
    }
  }
  
  // All in range
  strcpy(reason, "All parameters in range");
  return 0;
}

// ============================================
// DOSING EXECUTION WITH CSTR MIXING
// ============================================

void executeDose(int substrate, float doseML) {
  if (doseML < MIN_DOSE_ML) return;
  
  int pumpPin;
  float subPH, subEC, subDO;
  float subFe, subZn, subCu, subMn, subSe, subNi, subCo;
  const char* name;
  
  switch (substrate) {
    case 1: // Wine
      pumpPin = PUMP_WINE;
      subPH = WINE_PH; subEC = WINE_EC; subDO = WINE_DO;
      subFe = WINE_FE; subZn = WINE_ZN; subCu = WINE_CU;
      subMn = WINE_MN; subSe = WINE_SE; subNi = WINE_NI; subCo = WINE_CO;
      name = "WINE";
      totalWineML += doseML;
      doseCountWine++;
      break;
      
    case 2: // Urine
      pumpPin = PUMP_URINE;
      subPH = URINE_PH; subEC = URINE_EC; subDO = URINE_DO;
      subFe = URINE_FE; subZn = URINE_ZN; subCu = URINE_CU;
      subMn = URINE_MN; subSe = URINE_SE; subNi = URINE_NI; subCo = URINE_CO;
      name = "URINE";
      totalUrineML += doseML;
      doseCountUrine++;
      break;
      
    case 3: // Spirulina
      pumpPin = PUMP_SPIRULINA;
      subPH = SPIR_PH; subEC = SPIR_EC; subDO = SPIR_DO;
      subFe = SPIR_FE; subZn = SPIR_ZN; subCu = SPIR_CU;
      subMn = SPIR_MN; subSe = SPIR_SE; subNi = SPIR_NI; subCo = SPIR_CO;
      name = "SPIRULINA";
      totalSpirML += doseML;
      doseCountSpir++;
      break;
      
    default:
      return;
  }
  
  // Calculate pump time
  float pumpTimeSec = doseML / PUMP_ML_PER_SEC;
  unsigned long pumpTimeMS = (unsigned long)(pumpTimeSec * 1000);
  
  // Print dose info
  Serial.print(F(">> DOSING ")); Serial.print(name);
  Serial.print(F(": ")); Serial.print(doseML, 1); Serial.print(F(" mL ("));
  Serial.print(pumpTimeSec, 1); Serial.println(F(" sec)"));
  
  // Calculate expected post-dose state (CSTR mixing)
  float newVol = reactorVolume + doseML;
  float newPH  = (currentPH * reactorVolume + subPH * doseML) / newVol;
  float newEC  = (currentEC * reactorVolume + subEC * doseML) / newVol;
  float newDO  = (currentDO * reactorVolume + subDO * doseML) / newVol;
  
  Serial.print(F("   Expected: pH=")); Serial.print(newPH, 2);
  Serial.print(F(" EC=")); Serial.print(newEC, 2);
  Serial.print(F(" DO=")); Serial.println(newDO, 2);
  
  // Activate pump
  digitalWrite(pumpPin, HIGH);
  delay(pumpTimeMS);
  digitalWrite(pumpPin, LOW);
  
  // Update state using CSTR mixing physics
  currentPH = (currentPH * reactorVolume + subPH * doseML) / newVol;
  currentEC = (currentEC * reactorVolume + subEC * doseML) / newVol;
  currentDO = (currentDO * reactorVolume + subDO * doseML) / newVol;
  
  // Update trace metals
  currentFe = (currentFe * reactorVolume + subFe * doseML) / newVol;
  currentZn = (currentZn * reactorVolume + subZn * doseML) / newVol;
  currentCu = (currentCu * reactorVolume + subCu * doseML) / newVol;
  currentMn = (currentMn * reactorVolume + subMn * doseML) / newVol;
  currentSe = (currentSe * reactorVolume + subSe * doseML) / newVol;
  currentNi = (currentNi * reactorVolume + subNi * doseML) / newVol;
  currentCo = (currentCo * reactorVolume + subCo * doseML) / newVol;
  
  reactorVolume = newVol;
}

// ============================================
// SENSOR READING
// ============================================

void readSensors() {
  long phRaw = 0, ecRaw = 0, doRaw = 0;
  
  // Average 10 readings for noise reduction
  for (int i = 0; i < 10; i++) {
    phRaw += analogRead(PH_SENSOR);
    ecRaw += analogRead(EC_SENSOR);
    doRaw += analogRead(DO_SENSOR);
    delay(10);
  }
  phRaw /= 10;
  ecRaw /= 10;
  doRaw /= 10;
  
  // Convert to units
  currentPH = PH_SLOPE * phRaw + PH_OFFSET;
  currentEC = EC_SLOPE * ecRaw + EC_OFFSET;
  currentDO = DO_SLOPE * doRaw + DO_OFFSET;
  
  // Constrain to valid ranges
  currentPH = constrain(currentPH, 0.0, 14.0);
  currentEC = constrain(currentEC, 0.0, 50.0);
  currentDO = constrain(currentDO, 0.0, 20.0);  // Can be supersaturated
}

// ============================================
// DRIFT APPLICATION (autonomous dynamics)
// ============================================
// 
// pH, EC: dx/dt = Ax + d (first-order decay + constant drift)
// DO:     dDO/dt = A_DO*DO + D_DO + kLa*(DO_sat - DO)
//
// The DO equation correctly models:
//   - Consumption proportional to DO (A_DO*DO, negative)
//   - Baseline consumption (D_DO, negative)  
//   - Reaeration toward saturation (kLa*(DO_sat - DO), positive when DO < sat)

void applyDrift(float dt) {
  // pH dynamics: first-order decay + constant drift
  float dPH = A_PH * currentPH + D_PH;
  
  // EC dynamics: first-order decay + constant drift
  float dEC = A_EC * currentEC + D_EC;
  
  // DO dynamics: consumption + reaeration
  // dDO/dt = A_DO*DO + D_DO + kLa*(DO_sat - DO)
  float consumption = A_DO * currentDO + D_DO;           // Negative (O2 consumed)
  float reaeration  = KLA * (DO_SATURATION - currentDO); // Positive when DO < sat
  float dDO = consumption + reaeration;
  
  // Euler integration
  currentPH += dPH * dt;
  currentEC += dEC * dt;
  currentDO += dDO * dt;
  
  // Metal decay (first-order)
  float decayFactor = exp(-METAL_DECAY_RATE * dt);
  currentFe *= decayFactor;
  currentZn *= decayFactor;
  currentCu *= decayFactor;
  currentMn *= decayFactor;
  currentSe *= decayFactor;
  currentNi *= decayFactor;
  currentCo *= decayFactor;
  
  // Enforce physical constraints
  currentPH = max(0.0, currentPH);
  currentEC = max(0.01, currentEC);
  currentDO = max(0.0, currentDO);      // Can't go negative
  currentDO = min(currentDO, 20.0);     // Cap at supersaturation limit
}

// ============================================
// STATUS DISPLAY
// ============================================

void printStatus() {
  Serial.println(F("\n=== MFC STATUS ==="));
  
  // pH
  Serial.print(F("pH:  "));
  Serial.print(currentPH, 2);
  if (currentPH < PH_MIN) Serial.print(F(" [LOW]"));
  else if (currentPH > PH_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.print(F("  (target: ")); Serial.print(PH_MIN); 
  Serial.print(F("-")); Serial.print(PH_MAX); 
  Serial.print(F(", setpoint: ")); Serial.print(PH_SETPOINT); Serial.println(F(")"));
  
  // EC
  Serial.print(F("EC:  "));
  Serial.print(currentEC, 2);
  Serial.print(F(" mS/cm"));
  if (currentEC < EC_MIN) Serial.print(F(" [LOW]"));
  else if (currentEC > EC_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.print(F("  (target: ")); Serial.print(EC_MIN); 
  Serial.print(F("-")); Serial.print(EC_MAX); Serial.println(F(")"));
  
  // DO
  Serial.print(F("DO:  "));
  Serial.print(currentDO, 2);
  Serial.print(F(" mg/L"));
  if (currentDO < DO_MIN) Serial.print(F(" [LOW]"));
  else if (currentDO > DO_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.print(F("  (target: ")); Serial.print(DO_MIN); 
  Serial.print(F("-")); Serial.print(DO_MAX);
  Serial.print(F(", sat: ")); Serial.print(DO_SATURATION); Serial.println(F(")"));
  
  // Volume
  Serial.print(F("Vol: "));
  Serial.print(reactorVolume, 0);
  Serial.println(F(" mL"));
  
  // Dose totals
  Serial.print(F("Dosed: Wine=")); Serial.print(totalWineML, 0);
  Serial.print(F("mL(")); Serial.print(doseCountWine); Serial.print(F(")"));
  Serial.print(F(" Urine=")); Serial.print(totalUrineML, 0);
  Serial.print(F("mL(")); Serial.print(doseCountUrine); Serial.print(F(")"));
  Serial.print(F(" Spir=")); Serial.print(totalSpirML, 0);
  Serial.print(F("mL(")); Serial.print(doseCountSpir); Serial.println(F(")"));
}

void printMetals() {
  Serial.println(F("--- TRACE METALS (mg/L) ---"));
  
  Serial.print(F("  Fe: ")); Serial.print(currentFe, 4);
  if (currentFe < FE_MIN) Serial.print(F(" [LOW]"));
  else if (currentFe > FE_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Zn: ")); Serial.print(currentZn, 4);
  if (currentZn < ZN_MIN) Serial.print(F(" [LOW]"));
  else if (currentZn > ZN_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Cu: ")); Serial.print(currentCu, 4);
  if (currentCu < CU_MIN) Serial.print(F(" [LOW]"));
  else if (currentCu > CU_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Mn: ")); Serial.print(currentMn, 4);
  if (currentMn < MN_MIN) Serial.print(F(" [LOW]"));
  else if (currentMn > MN_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Se: ")); Serial.print(currentSe, 5);
  if (currentSe < SE_MIN) Serial.print(F(" [LOW]"));
  else if (currentSe > SE_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Ni: ")); Serial.print(currentNi, 5);
  if (currentNi < NI_MIN) Serial.print(F(" [LOW]"));
  else if (currentNi > NI_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
  
  Serial.print(F("  Co: ")); Serial.print(currentCo, 5);
  if (currentCo < CO_MIN) Serial.print(F(" [LOW]"));
  else if (currentCo > CO_MAX) Serial.print(F(" [HIGH]"));
  else Serial.print(F(" [OK]"));
  Serial.println();
}

// ============================================
// SETUP
// ============================================

void setup() {
  Serial.begin(115200);
  
  pinMode(PUMP_WINE, OUTPUT);
  pinMode(PUMP_URINE, OUTPUT);
  pinMode(PUMP_SPIRULINA, OUTPUT);
  pinMode(STATUS_LED, OUTPUT);
  
  digitalWrite(PUMP_WINE, LOW);
  digitalWrite(PUMP_URINE, LOW);
  digitalWrite(PUMP_SPIRULINA, LOW);
  
  Serial.println(F("============================================"));
  Serial.println(F("MFC MODEL-PREDICTIVE CONTROL"));
  Serial.println(F("Physics-based dose calculation"));
  Serial.println(F("============================================"));
  Serial.println(F(""));
  Serial.println(F("CSTR mixing equation:"));
  Serial.println(F("  V_dose = V * (target - current) / (substrate - target)"));
  Serial.println(F(""));
  Serial.println(F("DO Dynamics Model:"));
  Serial.println(F("  dDO/dt = A_DO*DO + D_DO + kLa*(DO_sat - DO)"));
  Serial.print(F("  A_DO = ")); Serial.print(A_DO, 4); Serial.println(F(" /min (consumption coeff)"));
  Serial.print(F("  D_DO = ")); Serial.print(D_DO, 2); Serial.println(F(" mg/L/min (base consumption)"));
  Serial.print(F("  kLa  = ")); Serial.print(KLA, 2); Serial.println(F(" /min (reaeration)"));
  Serial.print(F("  DO_sat = ")); Serial.print(DO_SATURATION, 1); Serial.println(F(" mg/L"));
  Serial.println(F("  Steady-state DO (no input) ≈ 6.67 mg/L"));
  Serial.println(F(""));
  Serial.print(F("Dose range: ")); Serial.print(MIN_DOSE_ML, 1);
  Serial.print(F(" - ")); Serial.print(MAX_DOSE_ML, 1); Serial.println(F(" mL"));
  Serial.print(F("Control interval: ")); Serial.print(CONTROL_INTERVAL/1000);
  Serial.println(F(" seconds"));
  Serial.println(F(""));
  Serial.println(F("Targets:"));
  Serial.print(F("  pH: ")); Serial.print(PH_MIN); Serial.print(F("-")); 
  Serial.print(PH_MAX); Serial.print(F(" (setpoint ")); 
  Serial.print(PH_SETPOINT); Serial.println(F(")"));
  Serial.print(F("  EC: ")); Serial.print(EC_MIN); Serial.print(F("-")); 
  Serial.print(EC_MAX); Serial.print(F(" mS/cm (setpoint "));
  Serial.print(EC_SETPOINT); Serial.println(F(")"));
  Serial.print(F("  DO: ")); Serial.print(DO_MIN); Serial.print(F("-")); 
  Serial.print(DO_MAX); Serial.print(F(" mg/L (setpoint "));
  Serial.print(DO_SETPOINT); Serial.println(F(")"));
  Serial.println(F(""));
  Serial.println(F("Priority: pH > DO > EC"));
  Serial.println(F("============================================"));
  Serial.println(F(""));
}

// ============================================
// MAIN LOOP
// ============================================

void loop() {
  unsigned long now = millis();
  
  if (now - lastControlTime >= CONTROL_INTERVAL) {
    lastControlTime = now;
    digitalWrite(STATUS_LED, HIGH);
    
    // Read sensors
    readSensors();
    
    // Display current state
    printStatus();
    
    // MPC control decision
    float doseML = 0;
    char reason[80];
    int action = mpcControlDecision(&doseML, reason);
    
    Serial.print(F("\n>> DECISION: ")); Serial.println(reason);
    
    // Execute dose if needed
    if (action > 0 && doseML >= MIN_DOSE_ML) {
      executeDose(action, doseML);
    }
    
    // Show trace metals periodically (every 10 cycles)
    static int cycleCount = 0;
    if (++cycleCount >= 10) {
      printMetals();
      cycleCount = 0;
    }
    
    // Apply drift for next cycle (dt = 1 minute)
    applyDrift(1.0);
    
    digitalWrite(STATUS_LED, LOW);
    Serial.println();
  }
}
